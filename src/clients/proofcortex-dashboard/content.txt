# ProofCortex Dashboard (Dioxus) - Project Scaffold

This document contains a ready-to-use scaffold and starter code for a **Dioxus (WASM) web dashboard** that consumes the ProofCortex Public APIs described earlier.

It references your architecture diagram (used in the UI) at the local path below — use this as the image URL in the app:

**ARCHITECTURE IMAGE URL (local path):**
`/mnt/data/A_flowchart_in_digital_diagram_format_illustrates_.png`

---

## Quick Overview
- Framework: **Dioxus (WASM)**
- Build tool: **dioxus-cli** (recommended)
- Purpose: Dashboard to view proofs, submit demo proofs, view model registry and trust scores
- Integration: calls ProofCortex Public API endpoints (e.g. `/proofs/submit`, `/proofs/:id`, `/models`, `/trust/:model_id`)

---

## 1) Create the project

Run:

```bash
cargo install dioxus-cli --locked    # if not installed
cargo new proofcortex-dashboard --bin
cd proofcortex-dashboard
```

Edit `Cargo.toml` to include Dioxus web dependencies. Replace contents with:

```toml
[package]
name = "proofcortex-dashboard"
version = "0.1.0"
edition = "2021"

[dependencies]
dioxus = { version = "0.4", features = ["web"] }
dioxus-web = "0.4"
serde = { version = "1.0", features = ["derive"] }
serde_json = "1.0"
reqwest = { version = "0.11", features = ["json", "wasm"] }
wasm-bindgen = "0.2"
js-sys = "0.3"
web-sys = { version = "0.3", features = ["Window", "Request", "Response"] }
anyhow = "1.0"
```

> Note: versions may be updated; use `cargo add` if you prefer.

---

## 2) Project structure (recommended)

```
proofcortex-dashboard/
  Cargo.toml
  index.html
  src/
    main.rs
    app.rs
    components/
      header.rs
      dashboard.rs
      proof_list.rs
      proof_view.rs
      model_registry.rs
    api.rs
    utils.rs
  static/
    assets/
      architecture.png   # copy the architecture image here (or serve from path)
```

Place the architecture file at `static/assets/architecture.png` or use the local path above.

---

## 3) index.html

Create `index.html` (simple mounting point)

```html
<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ProofCortex Dashboard</title>
    <style>
      body { font-family: system-ui, -apple-system, 'Segoe UI', Roboto, 'Helvetica Neue', Arial; margin:0; }
      .container { max-width: 1100px; margin: 2rem auto; padding: 1rem; }
    </style>
  </head>
  <body>
    <div id="main"></div>
    <script type="module">import init from './pkg/proofcortex_dashboard.js'; init();</script>
  </body>
</html>
```

---

## 4) src/main.rs

```rust
use dioxus::prelude::*;
mod app;

fn main() {
    // bootstrap for web
    dioxus_web::launch(app::app);
}
```

---

## 5) src/app.rs

```rust
use dioxus::prelude::*;
mod components;
use components::dashboard::Dashboard;

pub fn app(cx: Scope) -> Element {
    cx.render(rsx!(
        style { "body { background: #f7fafc; color: #0f172a; }" }
        div { class: "container",
            h1 { "ProofCortex Dashboard" }
            p { "Verifiable AI inference proofs & model registry" }
            Dashboard {}
        }
    ))
}
```

---

## 6) src/components/dashboard.rs

```rust
use dioxus::prelude::*;
use crate::components::proof_list::ProofList;
use crate::components::model_registry::ModelRegistry;

pub fn Dashboard(cx: Scope) -> Element {
    cx.render(rsx!(
        div {
            style: "display:flex; gap:2rem;",
            div { style: "flex:2;",
                h2 { "Recent Proofs" }
                ProofList {}
            }
            div { style: "flex:1; background:#fff; padding:1rem; border-radius:8px; box-shadow:0 2px 6px rgba(0,0,0,0.06);",
                h3 { "Models & Trust" }
                ModelRegistry {}
            }
        }
    ))
}
```

---

## 7) src/components/proof_list.rs

```rust
use dioxus::prelude::*;
use serde::Deserialize;
use crate::api;

#[derive(Deserialize, Debug, Clone)]
struct ProofEntry { proofId: String, modelId: String, valid: bool }

pub fn ProofList(cx: Scope) -> Element {
    let proofs = use_state(&cx, || Vec::<ProofEntry>::new());
    use_effect(&cx, (), { let proofs = proofs.clone(); async move {
        // fetch events from public API
        if let Ok(v) = api::fetch_recent_events().await {
            proofs.set(v);
        }
    }});

    cx.render(rsx!(
        ul {
            for proof in proofs.get().iter().map(|p| rsx!(
                li { key: "{p.proofId}", style: "padding:0.5rem 0; border-bottom:1px solid #eee;",
                    div { strong { "{p.modelId}" } }
                    div { small { "Proof: {p.proofId} — " } span { if p.valid { "VALID" } else { "INVALID" } } }
                }
            ))
        }
    ))
}
```

---

## 8) src/components/model_registry.rs

```rust
use dioxus::prelude::*;
use serde::{Serialize, Deserialize};
use crate::api;

#[derive(Serialize, Deserialize, Clone, Debug)]
struct ModelInfo { model_id: String, name: String, owner: String, description: String, trust: Option<f64> }

pub fn ModelRegistry(cx: Scope) -> Element {
    let models = use_state(&cx, || Vec::<ModelInfo>::new());
    use_effect(&cx, (), { let models = models.clone(); async move {
        if let Ok(ms) = api::fetch_models().await {
            models.set(ms);
        }
    }});

    cx.render(rsx!(
        div {
            for m in models.get().iter().map(|m| rsx!(
                div { key: "{m.model_id}", style: "margin-bottom:1rem;",
                    h4 { "{m.name}" }
                    p { "{m.description}" }
                    p { small { "Owner: {m.owner} — Trust: {m.trust.unwrap_or(0.0)}" } }
                }
            ))
        }
    ))
}
```

---

## 9) src/api.rs

```rust
use serde::{Deserialize, Serialize};
use reqwest::Client;
use anyhow::Result;

const BASE: &str = "http://localhost:8080"; // change to deployed endpoint

#[derive(Deserialize, Debug, Clone)]
pub struct ProofEvent { pub proofId: String, pub modelId: String, pub submitter: String, pub valid: bool }

pub async fn fetch_recent_events() -> Result<Vec<ProofEvent>> {
    let client = Client::new();
    let url = format!("{}/proofs/events/recent", BASE);
    let resp = client.get(&url).send().await?.json::<Vec<ProofEvent>>().await?;
    Ok(resp)
}

#[derive(Deserialize, Debug, Clone)]
pub struct ModelInfo { pub model_id: String, pub name: String, pub owner: String, pub description: String, pub trust: Option<f64> }

pub async fn fetch_models() -> Result<Vec<ModelInfo>> {
    let client = Client::new();
    let url = format!("{}/models", BASE);
    let resp = client.get(&url).send().await?.json::<Vec<ModelInfo>>().await?;
    Ok(resp)
}
```

---

## 10) src/utils.rs

```rust
// Small helpers (formatting, time)
pub fn short_addr(addr: &str) -> String {
    if addr.len() > 12 { format!("{}...{}", &addr[..6], &addr[addr.len()-4..]) } else { addr.to_string() }
}
```

---

## 11) Build & Run (Development)

Install dioxus-cli (if not already):

```bash
cargo install dioxus-cli --locked
```

Run dev server:

```bash
dioxus serve --open
```

This will build the app to WASM and open a dev server.

---

## 12) Production Build

```bash
dioxus build --release
# serve the generated `dist/` directory with any static host
```

---

## 13) Notes & Next Steps
- Replace `BASE` in `src/api.rs` with your actual public API URL (and add CORS support server-side).  
- Add Wallet signing flow via JS glue (`wasm-bindgen`) if you want users to sign receipts from the browser.  
- Embed architecture image: copy `/mnt/data/A_flowchart_in_digital_diagram_format_illustrates_.png` to `static/assets/architecture.png` and add an `<img>` in Dashboard.  
- Extend components: Proof detail page, proof submission UI, live event streaming via WebSocket.

---

If you want, I can now:
- generate this scaffold as files on the canvas ready to download, or
- create a GitHub repo zip, or
- implement wallet signing glue code and a proof submission form.

Which next? 

